<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Map Force</title>
</head>
<style>
    .link {
        stroke: #ccc;
        stroke-width: 1;
    }
</style>

<body>
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script>
        var width = 1000;
        var height = 1000;

        var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height)
            .append("g")
            .attr("transform", "translate(0,0)");

        var projection = d3.geo.mercator()
            .center([107, 31])
            .scale(850)
            .translate([width / 2, height / 2]);

        var path = d3.geo.path() //用于绘制地图路径，里面传入投影函数 projection
            .projection(projection); //将三维地图的坐标投影到二维

        // force 是定义力学图的 Layout
        var force = d3.layout.force().size([width, height]);

        var color = d3.scale.category20();


        d3.json("china_simplify.json", function(error, root) {
            //读取后的文件信息都存在变量 root 中
            if (error)
                return console.error(error);
            console.log(root.features);

            var nodes = [];
            var links = [];

            // 对于 root.features 中存有每一个省的数据， 
            // root.features.forEach() 即对每一个省的数据， 。
            root.features.forEach(function(d, i) {
                // 函数里计算出各省的中点， 
                // 保存在 centroid.x 和 centroid.y 中， 
                // 再把其他信息赋值给 centroid.feature， 最后插入到 nodes 中
                var centroid = path.centroid(d);
                centroid.x = centroid[0];
                centroid.y = centroid[1];
                centroid.feature = d;
                nodes.push(centroid);
            });

            // 对 nodes 中的顶点进行三角剖分，即用三角形来连接各顶点，结果保存在 triangles 中
            var triangles = d3.geom.voronoi().triangles(nodes);

            // 将三角形的各边存到 links 变量中。 
            triangles.forEach(function(d, i) {
                links.push(edge(d[0], d[1]));
                links.push(edge(d[1], d[2]));
                links.push(edge(d[2], d[0]));
            });

            console.log(nodes);
            console.log(links);

            force.gravity(0)
                .charge(0)
                .nodes(nodes)
                .links(links)
                .linkDistance(function(d) {
                    return d.distance;
                })
                .start();

            // 绘制各顶点，即中国各省。
            // 其中要注意，第11行和第14行，是完全相反的两个平移函数，
            // 不错，这么做就是为了移过去，再移回来，
            // 即初始时显示的是各省拼成的完整的地图且显示在最初设定的位置，
            // 因为拖拽的过程中变化的量是 d.x 和 d.y ，所以要这么做。
            var node = svg.selectAll("g")
                .data(nodes)
                .enter().append("g")
                .attr("transform", function(d) {
                    return "translate(" + -d.x + "," + -d.y + ")";
                })
                .call(force.drag)
                .append("path")
                .attr("transform", function(d) {
                    return "translate(" + d.x + "," + d.y + ")";
                })
                .attr("stroke", "#000")
                .attr("stroke-width", 1)
                .attr("fill", function(d, i) {
                    return color(i);
                })
                .attr("d", function(d) {
                    return path(d.feature);
                });

            // 绘制连接各省的线条
            var link = svg.selectAll("line")
                .data(links)
                .enter()
                .append("line")
                .attr("class", "link")
                .attr("x1", function(d) {
                    return d.source.x;
                })
                .attr("y1", function(d) {
                    return d.source.y;
                })
                .attr("x2", function(d) {
                    return d.target.x;
                })
                .attr("y2", function(d) {
                    return d.target.y;
                });

            // tick 指的是时间间隔，也就是每一个时间间隔之后就刷新一遍画面，
            // 刷新的内容写在后面的无名函数 function 中， function 函数中写上作图的内容。
            // 这里看到了吧，第7-9行里是用于平移的，平移的参数为 d.x 和 d.y 。
            force.on("tick", function() {
                link.attr("x1", function(d) {
                        return d.source.x;
                    })
                    .attr("y1", function(d) {
                        return d.source.y;
                    })
                    .attr("x2", function(d) {
                        return d.target.x;
                    })
                    .attr("y2", function(d) {
                        return d.target.y;
                    });

                node.attr("transform", function(d) {
                    return "translate(" + d.x + "," + d.y + ")";
                });
            });
        });

        function edge(a, b) {
            var dx = a[0] - b[0],
                dy = a[1] - b[1];
            return {
                source: a,
                target: b,
                distance: Math.sqrt(dx * dx + dy * dy)
            };
        }
    </script>

</body>

</html>